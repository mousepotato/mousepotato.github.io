---
layout: post
title: 基于Spring2.5 Annotation的JUnit单元测试总结
tags:
- Java
- Technique
status: publish
type: post
published: true
meta:
  views: '1014'
  _edit_last: '1'
---
敏捷开发强调测试先行。基于TDD(Test Driven Develop)的测试流程大体上分为：



* 编写测试代码



* 运行测试



* 完善(重构)代码



* 再测试



* 最终测试通过



基于Spring2.5 Annotation的单元测试还是比较简单的。这里要用到的JUnit4.4及以上版本的某些功能，大多数MyEclipse（如6.0/6.5/7）自带了JUnit3.8和JUnit4.3版本。所有为了能用Spring2.5提供的新功能，请重新下载JUnit并在MyEclipse中你的项目类路径中导入jar包，最新版本的JUnit4.5可以<a href="http://sourceforge.net/project/downloading.php?group_id=15278&amp;filename=junit4.5.zip&amp;a=95865840">点击这里</a>下载（下载的zip包可以解压出jar文件）



下面是一个完整的单元测试代码其中用到了很多Spring的Annotation功能。可以参看一下，对于某些暂时不想实现的功能，可以在方法上加@Ignore 标注

<pre lang="java5">/**

*

* Description:

*

* @RunWith - JUnit annotation that specifies that the Spring class runner

*          should be used for running the test.

* @ContextConfiguration - Specifies the location of your Spring application

*                       context xml file(s). This gets inherited by subclasses,

*                       so you can use it in a base class to configure all of

*                       the tests in your application.

* @Test - Indicates that the method should be run as a test. Note that although

*       I used the pre JUnit 4 naming conventions (class names postfixed with

*       "Test" and method names prefixed with "test"), this is not a

*       requirement.

* @Ignore - When this annotation is added, the associated test method will not

*         be run. This is a great alternative to commenting out the methods

*         which was required prior to JUnit 4. In this case, the test would

*         fail if the

* @Ignore annotation wasn't used because objectUnderTest.getSomethingFalse()

*         does not equal true.

* @Autowired - Indicates that Spring should "wire" this dependency when

*            initializing the test. In this case, a Spring bean named

*            objectUnderTest will be provided.

*

*

* 要创建一个基于Spring2.5的JUnit4.4测试用例其实相当简单，主要进行以下几步的工作：

* (1)创建一个扩展自AbstractTransactionalJUnit4SpringContextTests的类，该基类是Spring2.5为方便在JUnit4环境进行事务测试的类，它还提供了一个simpleJdbcTemplate属性让你可以方便地操控数据库表，便于对测试数据进行有效的操作；

* (2)用@ContextLocation注解指定你要加载的Spring配置信息所在的位置；（默认的加载文件信息请参阅Spring

* Documentation）；

* (3)用@Autowired或@Resource注解注入你的Service接口，@Autowrired是指按类型将Spring

* Bean注入；而@Resource则按名称将Spring Bean注入。

* (4)用@Before准备待测试的数据，如果我们的数据库表结构没有任何数据，则可以在这里预先插入记录，以便进行单元测试，当整个测试完成后，这些数据都不会被保留在数据库中。

* (5)在需要进行测试的方法上使用JUnit4.4提供的@Test注解进行标示；

*

*

* Test类可以选择继承 extends AbstractTransactionalJUnit4SpringContextTests

*

*

* Copyright (c) 2008-2009 paraDise sTudio(DT). All Rights Reserved.

* @version 1.0 Apr 13, 2009 5:08:34 PM mousepotato（<a href="mailto:paradise.lsj@gmail.com">paradise.lsj#gmail.com</a>）created

*/



@RunWith(SpringJUnit4ClassRunner.class)

// applicationContext*.xml这种匹配写法，是不支持的，有多少个配置文件，就引入多少个。

@ContextConfiguration(locations = { "classpath:/applicationContext.xml" })

// @TestExecutionListeners({DependencyInjectionTestExecutionListener.class})

public class ApartmentDAOImplTest {

private static Logger log = Logger.getLogger(ApartmentDAOImplTest.class);



@Autowired

private ApartmentDAOImpl apartmentDAOImpl;



// ApplicationContext ac = null;

//

// @Before

// public void setup() {

// ac = new ClassPathXmlApplicationContext("applicationContext.xml");

// }



@SuppressWarnings("unchecked")

@Test

public void testListAllApartment() {

//

List lst = apartmentDAOImpl.listAllApartment();

log.info(lst.size());

}



@Test

@Ignore

public void testFindApartmentByName() {

fail("Not yet implemented");

}



public ApartmentDAOImpl getApartmentDAOImpl() {

return apartmentDAOImpl;

}



public void setApartmentDAOImpl(ApartmentDAOImpl apartmentDAOImpl) {

this.apartmentDAOImpl = apartmentDAOImpl;

}

}</pre>

请在项目中增加Spring-test.jar, apache的commons-下的包最好都加上。(项目中你基本都能用上)

还要注意你的配置文件路径。
